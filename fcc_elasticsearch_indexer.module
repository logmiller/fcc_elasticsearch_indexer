<?php

/*------------------------------------------------------------------------------
# Load Includes
------------------------------------------------------------------------------*/
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.common' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.types' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch_indexer.prepare' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch_indexer.fields' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch_indexer.api' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.sitenames' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.subdomains' );

/*------------------------------------------------------------------------------
# Module Setup
------------------------------------------------------------------------------*/

# Declare Constants
//define( 'ES_INDEX', fcc_es_get_cluster_index() );  // Name of the target ElasticSearch index.
//define( 'ES_URL', fcc_es_get_cluster_url() );
//define( 'ES_PORT', fcc_es_get_cluster_port() );

// TODO replace with variables framework
define( 'ES_INDEX', 'fccnn' );  // Name of the target ElasticSearch index.
define( 'ES_URL', 'https://3590b9d403c87e0697b6:8c2e5209a1@f08f4b1b.qb0x.com:30242' );
define( 'ES_PORT', '30242' );

/*------------------------------------------------------------------------------
# Node Functions
------------------------------------------------------------------------------*/

/**
 * Prepares a node to be added to elastic
 *
 * @param object $node
 * @return array $params
 */
function _fcc_elasticsearch_indexer_prepare_node( $node ) {
	if ( ! is_object( $node ) ) {
		return;
	}
	//print_r( $node . "\n" );

	// Populate the document metadata
	$params = _fcc_elasticsearch_indexer_prepare_document_metadata( $node );
	//print_r( $params . "\n" );

	// Populate the document fields based on article type
	if ( fcc_es_is_supported_node_type( $node->type ) ) {
		$fields = call_user_func( '_fcc_elasticsearch_indexer_prepare_' . $node->type, $node );
		foreach ( $fields as $key => $value ) { // Add the body fields to the document metadata
			$params['body'][ $key ] = $value;
		}
	} else {
		if ( drupal_is_cli() && function_exists( 'drush_main' ) ) { // Drush
			drush_set_error( 'Error: node type is currently unsupported.' );
			return;
		} else { // Drupal
			drupal_set_message( t( 'There was a problem saving this node to Elasticsearch - node type is currently unsupported.' ) );
		}
	}

	return $params;
}

/**
 * Implements hook_node_insert().
 *
 * @param object $node
 */
function fcc_elasticsearch_indexer_node_insert( $node ) {

	$document = _fcc_elasticsearch_indexer_prepare_node( $node );

	if ( ! $document ) {
		drupal_set_message( t( 'There was a problem saving this node to Elasticsearch. (No document provided.)' ) );
		return;
	}

	$result = fcc_es_post_single( $document ); // send the index request

	if ( false === $result && $result['created'] ) {
		drupal_set_message( t( 'There was a problem saving this node to Elasticsearch.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, $result );
		return;
	}

	drupal_set_message( t( 'The node has been saved to Elasticsearch.' ) );
}

/**
 * Implements hook_node_update().
 *
 * @param object $node
 */
function fcc_elasticsearch_indexer_node_update( $node ) {
	if ( false !== $node->is_new ) {
		return;
	}

	$document = _fcc_elasticsearch_indexer_prepare_node( $node );

	$result = fcc_es_query_single( $document );

	if ( ! $result && $result['_id'] ) {
		drupal_set_message( t( 'There was a problem updating this node in Elasticsearch. (Matching document not found for update.)' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Matching document not found for update.' );
		return;
	}

	$version = $result['_version'];
	$index = fcc_es_post_single( $document ); // send the index request

	if ( $index['_version'] !== $version + 1 ) {
		drupal_set_message( t( 'There was a problem updating this node in Elasticsearch. (Incremented version not returned)' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Incremented version not returned' );
		return;
	}

	drupal_set_message( t( 'The node has been updated in Elasticsearch.' ) );
}

/**
 * Implements hook_node_delete().
 *
 * @param object $node
 */
function fcc_elasticsearch_indexer_node_delete( $node ) {

	$document = array(
	  'index' => ES_INDEX,
	  'type' => $node->type,
	  'id' => $node->nid,
	);

	fcc_es_delete_single( $document ); // send the delete request

	if ( ! $result && $result['found'] ) {
		drupal_set_message( t( 'There was a problem deleting this node in Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'There was a problem deleting this node in Elasticsearch.' );
		return;
	}

	drupal_set_message( t( 'The node has been deleted in Elasticsearch.' ) );
}

/*------------------------------------------------------------------------------
# Error Handling and Validation
------------------------------------------------------------------------------*/

/**
 * Push errors to 'elasticsearch_reindex' table.
 * @param type $responses
 */
function _fcc_elasticsearch_set_error_log( $responses ) {
	foreach ( $responses['items'] as $items ) {
		db_merge( 'elasticsearch_logs' )
	      ->key( array( 'nid' => $items['index']['_id'] ) )
	      ->fields(array(
					'type' => $items['index']['_type'],
					'log_time' => REQUEST_TIME,
					'message' => json_encode( $items['index']['error'] ),
					))
					->execute();
	}
}

/**
 * Push errors to 'elasticsearch_reindex' table (single node/non-bulk).
 * @param type $responses
 */
function _fcc_elasticsearch_set_single_error_log( $node, $result ) {
	db_merge( 'elasticsearch_logs' )
			->key( array( 'nid' => $node->nid ) )
			->fields( array(
				'type' => $node->type,
				'log_time' => REQUEST_TIME,
				'message' => json_encode( $result ),
			))
			->execute();
}

/*------------------------------------------------------------------------------
# Cluster Variable Handling
------------------------------------------------------------------------------*/

/**
 * Set the cluster url used for elasticsearch.
 *
 * @param string $url
 * @return string
 */
function fcc_es_set_cluster_url( $url ) {
	fcc_es_set_cluster_port( $url );
	return variable_set( 'es_url', $url );
}

/**
 * Get the cluster url used for elasticsearch.
 *
 * @return string
 */
function fcc_es_get_cluster_url() {
	return variable_get( 'es_url', '' );
}

/**
 * Sets the ElasticSearch Server port variable from the url address
 * @param string $url
 * @return string $port
 */
function fcc_es_set_cluster_port( $url ) {
	$port = preg_replace( '(.+:)', '', $url );
	return variable_set( 'es_port', $port );
}

/**
 * Returns the ElasticSearch Server port from the url address
 * @param string $url
 * @return string $port
 */
function fcc_es_get_cluster_port() {
	return variable_get( 'es_port', '' );
}

/**
 * Set the cluster index name used for elasticsearch.
 *
 * @param string $index
 * @return string
 */
function fcc_es_set_cluster_index( $index ) {
	return variable_set( 'es_index', $index );
}

/**
 * Get the cluster index name used for elasticsearch.
 *
 * @param string $index
 * @return string
 */
function fcc_es_get_cluster_index() {
	$index = variable_get( 'es_index', '' );
	if ( ! $index ) {
		$index = 'fccnn'; // default
	}
	return $index;
}
