<?php

/*------------------------------------------------------------------------------
# Load Includes
------------------------------------------------------------------------------*/
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.types' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch_indexer.prepare' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch_indexer.fields' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch_indexer.api' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.sitenames' );
module_load_include( 'inc', 'fcc_elasticsearch_indexer', 'fcc_elasticsearch.subdomains' );

/*------------------------------------------------------------------------------
# Module Setup
------------------------------------------------------------------------------*/
$cluster = elasticsearch_connector_cluster_load( elasticsearch_connector_get_default_connector() );

# Declare Constants
define( 'DEFAULT_CLUSTER_ID', $cluster->cluster_id ); // TODO remove once Connector module dependancy is deprecated
define( 'ES_INDEX', fcc_es_get_cluster_index() );  // Name of the target ElasticSearch index.
define( 'ES_URL', fcc_es_get_cluster_url() );
define( 'ES_PORT', fcc_es_get_cluster_port() );

/*------------------------------------------------------------------------------
# Node Functions
------------------------------------------------------------------------------*/

/**
 * Prepares a node to be added to elastic
 *
 * @param object $node
 * @return array $params
 */
function _fcc_elasticsearch_indexer_prepare_node( $node ) {
	if ( ! is_object( $node ) ) {
		return;
	}

	// Populate the document metadata
	$params = _fcc_elasticsearch_indexer_prepare_document_metadata( $node );

	// Populate the document fields based on article type
	if ( fcc_es_is_supported_node_type( $node->type ) ) {
		$fields = call_user_func( '_fcc_elasticsearch_indexer_prepare_' . $node->type, $node );
		foreach ( $fields as $key => $value ) { // Add the body fields to the document metadata
			$params['body'][ $key ] = $value;
		}
	} else {
		if ( drupal_is_cli() && function_exists( 'drush_main' ) ) { // Drush
			drush_set_error( 'Error: node type is currently unsupported.' );
			return;
		} else { // Drupal
			drupal_set_message( t( 'There was a problem saving this node to Elastic - node type is currently unsupported.' ) );
		}
	}

	return $params;
}

/**
 * Helper function that returns a node from Elastic by its nid.
 *
 * @param $client
 * @param object $node
 * @return mixed
 */
function _fcc_elasticsearch_indexer_perform_node_search_by_id( $client, $node ) {
	$search = array(
		'index' => ES_INDEX,
		'type' => $node->type,
		'version' => true,
		'body' => array(
		  'query' => array(
		    'match' => array(
		      'nid' => $node->nid,
		    ),
		  ),
		),
	);

	return $client->search( $search );
}

/**
 * Implements hook_node_insert().
 *
 * @param object $node
 */
function fcc_elasticsearch_indexer_node_insert( $node ) {
	$client = elasticsearch_connector_get_client_by_id( DEFAULT_CLUSTER_ID );
	$params = _fcc_elasticsearch_indexer_prepare_node( $node );

	if ( ! $params ) {
		drupal_set_message( t( 'There was a problem saving this node to Elastic.' ) );
		return;
	}

	$result = $client->index( $params );
	if ( false === $result && $result['created'] ) {
		drupal_set_message( t( 'There was a problem saving this node to Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, $result );
		return;
	}

	drupal_set_message( t( 'The node has been saved to Elastic.' ) );
}

/**
 * Implements hook_node_update().
 *
 * @param object $node
 */
function fcc_elasticsearch_indexer_node_update( $node ) {
	if ( false !== $node->is_new ) {
		return;
	}

	$client = elasticsearch_connector_get_client_by_id( DEFAULT_CLUSTER_ID );

	if ( ! fcc_es_index_exists( ES_INDEX, $client ) ) {
		drupal_set_message( t( 'There was a problem updating this node in Elastic. (Index does not exist)' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Index does not exist' );
		return;
	}

	$params = _fcc_elasticsearch_indexer_prepare_node( $node );

	if ( ! $params ) {
		drupal_set_message( t( 'There was a problem updating this node in Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Parameters Error' );
		return;
	}

	$result = _fcc_elasticsearch_indexer_perform_node_search_by_id( $client, $node );
	if ( 1 !== $result && $result['hits']['total'] ) {
		drupal_set_message( t( 'There was a problem updating this node in Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Matching document not found for update.' );
		return;
	}

	$params['id'] = $result['hits']['hits'][0]['_id'];
	$version = $result['hits']['hits'][0]['_version'];
	$index = $client->index( $params );
	if ( $index['_version'] !== $version + 1 ) {
		drupal_set_message( t( 'There was a problem updating this node in Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Incremented version not returned' );
		return;
	}

	drupal_set_message( t( 'The node has been updated in Elastic.' ) );
}

/**
 * Implements hook_node_delete().
 *
 * @param object $node
 */
function fcc_elasticsearch_indexer_node_delete( $node ) {
	$client = elasticsearch_connector_get_client_by_id( DEFAULT_CLUSTER_ID );

	if ( ! fcc_es_index_exists( ES_INDEX, $client ) ) {
		drupal_set_message( t( 'There was a problem deleting this node in Elastic. (Index does not exist)' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Index does not exist' );
		return;
	}

	// If the node is in Elastic, remove it
	$result = _fcc_elasticsearch_indexer_perform_node_search_by_id( $client, $node );
	if ( 1 !== $result && $result['hits']['total'] ) {
		drupal_set_message( t( 'There was a problem deleting this node in Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'Matching document not found for deletion.' );
		return;
	}

	$params = array(
	  'index' => ES_INDEX,
	  'type' => $node->type,
	  'id' => $result['hits']['hits'][0]['_id'],
	);

	$result = $client->delete( $params );
	if ( ! $result && $result['found'] ) {
		drupal_set_message( t( 'There was a problem deleting this node in Elastic.' ) );
		_fcc_elasticsearch_set_single_error_log( $node, 'There was a problem deleting this node in Elastic.' );
		return;
	}

	drupal_set_message( t( 'The node has been deleted in Elastic.' ) );
}

/*------------------------------------------------------------------------------
# Error Handling and Validation
------------------------------------------------------------------------------*/

/**
 * Verifies if a specific index exists
 *
 * @param string $index
 * @param mixed $client (optional)
 */
function fcc_es_index_exists( $index, $client = null ) {
	if ( ! $client ) {
		$client = elasticsearch_connector_get_client_by_id( DEFAULT_CLUSTER_ID );
	}
	$index_exists = $client->indices()->exists( array( 'index' => $index ) );
	return $index_exists;
}

/**
 * Push errors to 'elasticsearch_reindex' table.
 * @param type $responses
 */
function _fcc_elasticsearch_set_error_log( $responses ) {
	foreach ( $responses['items'] as $items ) {
		db_merge( 'elasticsearch_logs' )
	      ->key( array( 'nid' => $items['index']['_id'] ) )
	      ->fields(array(
					'type' => $items['index']['_type'],
					'log_time' => REQUEST_TIME,
					'message' => json_encode( $items['index']['error'] ),
					))
					->execute();
	}
}

/**
 * Push errors to 'elasticsearch_reindex' table (single node/non-bulk).
 * @param type $responses
 */
function _fcc_elasticsearch_set_single_error_log( $node, $result ) {
	db_merge( 'elasticsearch_logs' )
			->key( array( 'nid' => $node->nid ) )
			->fields( array(
				'type' => $node->type,
				'log_time' => REQUEST_TIME,
				'message' => json_encode( $result ),
			))
			->execute();
}

/*------------------------------------------------------------------------------
# Cluster Variable Handling
------------------------------------------------------------------------------*/

/**
 * Set the cluster url used for elasticsearch.
 *
 * @param string $url
 * @return string
 */
function fcc_es_set_cluster_url( $url ) {
	fcc_es_set_cluster_port( $url );
	return variable_set( 'es_url', $url );
}

/**
 * Get the cluster url used for elasticsearch.
 *
 * @return string
 */
function fcc_es_get_cluster_url() {
	return variable_get( 'es_url', '' );
}

/**
 * Sets the ElasticSearch Server port variable from the url address
 * @param string $url
 * @return string $port
 */
function fcc_es_set_cluster_port( $url ) {
	$port = preg_replace( '(.+:)', '', $url );
	return variable_set( 'es_port', $port );
}

/**
 * Returns the ElasticSearch Server port from the url address
 * @param string $url
 * @return string $port
 */
function fcc_es_get_cluster_port() {
	return variable_get( 'es_port', '' );
}

/**
 * Set the cluster index name used for elasticsearch.
 *
 * @param string $index
 * @return string
 */
function fcc_es_set_cluster_index( $index ) {
	return variable_set( 'es_index', $index );
}

/**
 * Get the cluster index name used for elasticsearch.
 *
 * @param string $index
 * @return string
 */
function fcc_es_get_cluster_index() {
	$index = variable_get( 'es_index', '' );
	if ( ! $index ) {
		$index = 'fccnn'; // default
	}
	return $index;
}
